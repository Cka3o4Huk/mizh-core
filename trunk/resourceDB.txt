 
www.intel.com

Very good site with many documents, data sheets, white papers and their same.
If you want to develop with new technologies, this is the correct site.

www.amd.com

Also a good site where you get the famous amd documents about the 64 bit technologie.
Documents from amd are very good written and easy to read.

www.osdever.net

osdever.net is a well-known OS development website with a huge collection of documents.

www.lowlevel.net.tc

A good OS development website on german, with a good forum with many (good) developers.
Peter Kleissner had learned there how to start with OS developing.  

-----------------------

По поводу тормознутости передачи параметров при обработке шлюза вызова:
этим явлением можно пренебречь, если учесть, что если пойти другим образом
(через шлюз ловушки), то надо будет эти же данные параметров пихать из
памяти в регистры, а это займет еще больше времени, если учесть что проц
в первом случае копирует данные из стека в стек автоматически.

Поэтому я предлагаю сразу использовать дескриптор шлюза вызова в GDT,
а в проге (в служебных объектных файлах, которые автоматом линкуются
к проге) использовать прототип вида
int syscall(int,int,int,int,int,int,int);
И не надо делать никакой трансляции параметров в регистры.

Связи с этим такой вопрос: после вызова шлюза указатель стека не
изменяется ( в смысле в сравнении до и после дальнего call-а )?

То, что прописывается во всех шлюзах вызова и прерываний это
физический адрес или виртуальный? (т.к. в моей ОС пока что все равно - 
у меня первые 4Мб памати проецируются в 0x00000000 и 0xf0000000)

Категорически отрицаю возможность использования сегментно-страничной
организации памяти т.к. её можно (и нужно) заменить на страничную.

Для какой цели существует NMI? Зачем существует порт, в котором можно
его замаскировать?

Цитата: 
Мне же кажется, что в системах с виртуальной памятью вполне
можно остановиться на программном переключении. Как минимум
не придется перегружать LDTR, если LDT вообще используется. >Если так, то куда записывать дескрипторы сегментов стека
для каждого потока?

>Как правильно (через порты может) узнать объем ОЗУ?
Метод "записал=>проверил=>если равно, то здесь ОЗУ" не канает под
эмулатором Bochs например...

Обещаю выслать исходники APM выключения питания.
Где-то у меня были. Только там прикол в том, что это ОС, кде-то внутри
ядра определяется функция для работы с APM, так что одного сишного
файла, я думаю, будет мало... А основная часть все-таки в одном файле
лежит. Я в исходниках не разобрался - там что-то премудрое, но зато
универсальное, API состоит из множества вызовов, один из них - выключение
всех устройств.

По поводу "хитрого" ребута из "защищенного" "нуля" кто не знает - расскажу.
А вообще это есть в книге изд. Питер "ASSEMBLER Специальный справочник".

>Как правильно перейти в ring0+paging? Какой должен быть порядок настройки
GDT, таблицы страниц и Far Jmp-ов. Если кто желает помочь - могу выслать
исходники загрузчика ядра второго уровня, в котором собственно и глюк.
Закрузчик второго уровня у меня - файл на флопе, который загружается
бутсектором, а сам загружает ядро [в проекте - добавление туда дров на
устройства HDD,FDD,Flash,CD,DVD, а также закрузка вместе с ядром нужных
модулей].

>У меня еще идея появилась - сам придумал. Для доступа к физической
памяти, проецирования страниц можно воспользоваться следующим трюком:
в главном каталоге страниц (первого уровня) в 1024 (последней) ячейке
создается ссылка на страницу как обычно. В этой таблице(странице) в
первой ячейке делается ссылка на саму себя... Благодаря этому без
хитростей в этой странице можно создать еще 1023 дескриптора на нужные
физические страницы.
Если эта идея не нова - скажите, но я все равно рад, что до нее
додумался сам.

>Мое мнение по поводу защиты: надо сначала написать Ось, которая относилась
бы ко всем программам в том числе и драйверам как к очень злобным хакерам,
а потом делать поддержку защиты в ФС, сети, и т.д.
Из первого вытекает, что драйвера не должны быть на "нуле",
из последнего - что FAT не покатит.

Пишу ОС под FreeBSD 5.4, использую NASM(кстати, вещчь!), GCC (Си часть), Bochs
Все бинарники забиваю на образ флопика, ну а потом Bochs запускаю.
По поводу перехода на раздел винта еще не думал, т.к.:
- У меня на винте и так уже 4 раздела.
- Бинарники пока еще достаточно мало весят.

Писать ОСь под форточками как-то не хотелось...

Кстати, кому нужна кучища пакаджей под FreeBSD 5.4,6.0 лезьте
сюда: s28.zp.ua, а именно ftp://s28.zp.ua/pub/...
Там и NASM и Bochs и KDE...

В моей ОС уже русский язык есть . Путем перепрограммирования знакогенератора.
Думаю сделать еще что-то типа tty, т.к. не удобно менять цвет текста и проч.
параметры через тупые интерфейсы.

Единственно, что качественно(и то вроде бы) написано - так это подсистема
управления памятью (выделение, освобождение для каждого процесса).
Многозадачности пока нет.

Короче, че это тут я. Надо идеи обсуждать, а потом вместе что-то хорошее
слепить...

Я предлагаю такие идеи:
- ввести новый привелегированный режим(доступный только супервайзеру) - 
режим полной занятости. Т.е. некая программа может полностью занимать
рабочее время проца, а другие проги пусть стоят. Можно еще добавить
возможность временного отключения прерываний при работе в таком режиме.
Режим будет очень полезен для крупных расчетов, которые редко (а именно,
лучше только в начале и в конце работы) используют ресурсы диска и другие
устройства - таких приложений достаточное количество.
Режим выборочный - т.к. его использование возможно лишь на отдельных
(и от сети в том числе) рабочих станциях. Тут как раз что-то несетевое
предлагали писать...
- Ведение всевозможной статистики во всех "районах" ядра, а тем более в
драйверах устройств. Может быть полезно для мониторинга оптимальности
работы, для оптимизации операций ввода/вывода.

--------------

У меня загрузчик ядра делает так:
1.Включение A20 (для 32 битной адресации)
2.Создание GDT
3.Запрещение всех прерываний
4.Загрузка GDTR
5.Переключение в PM (far jump'ом)
6.Загрузка селекторов на дескрипторы в GDT
7.Создание IDT
8.Отключение APIC (если есть)
9.Перенаправление аппаратных прерываний
10.Загрузка IDTR 
11.Разрешение прерываний
12.Включение страничной адресации

-----

http://sasm.narod.ru/
http://bos.asmhackers.net/docs/pmode/a20/enableA20.s
